import multiprocessing
import sys
import traceback
from io import StringIO
from contextlib import redirect_stdout, redirect_stderr

def run_user_code(user_code, queue):
    try:
        # Redirect stdout and stderr
        stdout, stderr = StringIO(), StringIO()
        with redirect_stdout(stdout), redirect_stderr(stderr):
            # Create a separate namespace for user code execution
            user_namespace = {}
            exec(user_code, user_namespace)
        queue.put({'success': True, 'reason': 'success', 'stdout': stdout.getvalue(), 'stderr': stderr.getvalue(), 'variables': user_namespace})
    except BaseException as e:  # Catch all exceptions
        tb_str = traceback.format_exception(type(e), e, e.__traceback__)
        queue.put({'success': False, 'reason': 'error', 'stdout': stdout.getvalue(), 'stderr': "".join(tb_str)})

def execute_with_timeout(user_code, timeout_seconds):
    # Create a Queue object to manage shared state
    queue = multiprocessing.Queue()

    # Create a separate process to run the user code
    process = multiprocessing.Process(target=run_user_code, args=(user_code, queue))
    process.start()

    # Wait for the process to complete or until the timeout
    process.join(timeout_seconds)

    if process.is_alive():
        process.terminate()
        return {'success': False, 'reason': 'timeout', 'stdout': '', 'stderr': ''}

    return queue.get()

def assert_user_code(assert_code, user_code, variables, stdout):
    # Create a separate namespace for assert function execution
    assert_namespace = {'user_code': user_code, 'variables': variables, 'stdout': stdout, 'assert_passed': False, 'help_message': ''}
    try:
        exec(assert_code, assert_namespace)
    except AssertionError as e:
        assert_namespace['assert_passed'] = False
        assert_namespace['help_message'] = str(e)
    return assert_namespace['assert_passed'], assert_namespace['help_message']

def run_and_assert_code(user_code, test_code, timeout_seconds):
    code_result = execute_with_timeout(user_code, timeout_seconds)

    if code_result['success'] == False:
        return {
            'success': False,
            'reason': code_result['reason'],
            'helpMessage': '',
            'stdout': code_result['stdout'],
            'stderr': code_result['stderr']
        }
    
    assert_passed, help_message = assert_user_code(test_code, user_code, code_result['variables'], code_result['stdout'])

    return {
        'success': assert_passed,
        'reason': 'success' if assert_passed else 'assert-failed',
        'helpMessage': help_message,
        'stdout': code_result['stdout'],
        'stderr': code_result['stderr']
    }

'''
How to write an Assert Function:
In the assert function you are given these three variables:
user_code: str, variables: dict, stdout: str

user_code is what the user wrote at time of submission
variables is a dictionary of all the variables after execution (including system ones)
stdout is the raw standard output generated by the user code after execution

You should return a tuple of bool, str. The bool being whether your assertion was successful or not.
The str is an optional help_message if there's a specific failure case where you think extra explination is required.
If you do not wish to provide a help_message, return an empty string instead.
Returning is done by assigning a variable for 'assert_passed' and 'help_message'. If you set these and wish to stop your assertion early, use an empty return.

Example:
assert stdout == 'hello world\\n', "You should be printing the phrase 'hello world' exactly. Case sensitive."
assert 'hello' in variables and variables['hello'] == 'hello world', "variable 'hello' should have the value 'hello world'. Everything is case sensitive."
assert_passed = True
help_message = ''
'''